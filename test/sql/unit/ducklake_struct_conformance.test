# name: test/sql/unit/ducklake_struct_conformance.test
# description: Verify native DuckLake STRUCT type behavior that DuckHog integration tests rely on.
# group: [unit]

#              Conformance tests run DuckDB + DuckLake directly — no DuckHog, no Duckgres.
#              They document our assumptions about native DuckLake behavior so that when
#              an integration test fails, we can tell whether DuckLake changed underneath
#              us or whether our proxy is broken.

require parquet

statement ok
INSTALL ducklake;

statement ok
LOAD ducklake;

statement ok
ATTACH 'ducklake:__TEST_DIR__/ducklake_struct_conformance_meta.db' AS dl;

# ============================================================
# Basic STRUCT — CREATE + INSERT round-trip
# ============================================================

statement ok
CREATE TABLE dl.main.t_basic(id INT, s STRUCT(i INTEGER, j INTEGER));

statement ok
INSERT INTO dl.main.t_basic VALUES (1, {'i': 10, 'j': 20});

query IT
SELECT id, s FROM dl.main.t_basic;
----
1	{'i': 10, 'j': 20}

# Field access
query III
SELECT id, s.i, s.j FROM dl.main.t_basic;
----
1	10	20

# ============================================================
# NULL struct, struct with NULL fields
# ============================================================

statement ok
INSERT INTO dl.main.t_basic VALUES (2, NULL);

statement ok
INSERT INTO dl.main.t_basic VALUES (3, {'i': NULL, 'j': 42});

query IT
SELECT id, s FROM dl.main.t_basic WHERE id = 2;
----
2	NULL

query III
SELECT id, s.i, s.j FROM dl.main.t_basic WHERE id = 3;
----
3	NULL	42

# ============================================================
# STRUCT with VARCHAR fields
# ============================================================

statement ok
DROP TABLE IF EXISTS dl.main.t_varchar_struct;

statement ok
CREATE TABLE dl.main.t_varchar_struct(id INT, s STRUCT(name VARCHAR, city VARCHAR));

statement ok
INSERT INTO dl.main.t_varchar_struct VALUES (1, {'name': 'alice', 'city': 'NYC'});

query IT
SELECT id, s FROM dl.main.t_varchar_struct;
----
1	{'name': alice, 'city': NYC}

query ITT
SELECT id, s.name, s.city FROM dl.main.t_varchar_struct;
----
1	alice	NYC

# ============================================================
# Mixed scalar + STRUCT columns
# ============================================================

statement ok
DROP TABLE IF EXISTS dl.main.t_mixed;

statement ok
CREATE TABLE dl.main.t_mixed(name VARCHAR, info STRUCT(age INTEGER, city VARCHAR), score DOUBLE);

statement ok
INSERT INTO dl.main.t_mixed VALUES
    ('alice', {'age': 30, 'city': 'NYC'}, 95.5),
    ('bob', {'age': 25, 'city': 'LA'}, 87.3);

query TITR
SELECT name, info.age, info.city, score FROM dl.main.t_mixed ORDER BY name;
----
alice	30	NYC	95.5
bob	25	LA	87.3

# ============================================================
# UPDATE with STRUCT values
# ============================================================

statement ok
UPDATE dl.main.t_basic SET s = {'i': 99, 'j': 100} WHERE id = 1;

query IT
SELECT id, s FROM dl.main.t_basic WHERE id = 1;
----
1	{'i': 99, 'j': 100}

# ============================================================
# DELETE with STRUCT field condition
# ============================================================

statement ok
DELETE FROM dl.main.t_basic WHERE s.j = 42;

query I
SELECT COUNT(*) FROM dl.main.t_basic WHERE id = 3;
----
0

# ============================================================
# Nested STRUCT (STRUCT inside STRUCT)
# ============================================================

statement ok
DROP TABLE IF EXISTS dl.main.t_nested_struct;

statement ok
CREATE TABLE dl.main.t_nested_struct(id INT, s STRUCT(inner_s STRUCT(x INTEGER, y INTEGER), label VARCHAR));

statement ok
INSERT INTO dl.main.t_nested_struct VALUES (1, {'inner_s': {'x': 1, 'y': 2}, 'label': 'origin'});

query IT
SELECT id, s FROM dl.main.t_nested_struct;
----
1	{'inner_s': {'x': 1, 'y': 2}, 'label': origin}

query II
SELECT s.inner_s.x, s.inner_s.y FROM dl.main.t_nested_struct WHERE id = 1;
----
1	2

# ============================================================
# STRUCT with LIST field
# ============================================================

statement ok
DROP TABLE IF EXISTS dl.main.t_struct_list;

statement ok
CREATE TABLE dl.main.t_struct_list(id INT, s STRUCT(tags VARCHAR[], count INTEGER));

statement ok
INSERT INTO dl.main.t_struct_list VALUES (1, {'tags': ['a', 'b', 'c'], 'count': 3});

query IT
SELECT id, s FROM dl.main.t_struct_list;
----
1	{'tags': [a, b, c], 'count': 3}

query I
SELECT s.count FROM dl.main.t_struct_list WHERE id = 1;
----
3

# ============================================================
# LIST of STRUCTs
# ============================================================

statement ok
DROP TABLE IF EXISTS dl.main.t_list_struct;

statement ok
CREATE TABLE dl.main.t_list_struct(id INT, items STRUCT(name VARCHAR, qty INTEGER)[]);

statement ok
INSERT INTO dl.main.t_list_struct VALUES (1, [{'name': 'apple', 'qty': 5}, {'name': 'banana', 'qty': 3}]);

query IT
SELECT id, items FROM dl.main.t_list_struct;
----
1	[{'name': apple, 'qty': 5}, {'name': banana, 'qty': 3}]

query I
SELECT len(items) FROM dl.main.t_list_struct WHERE id = 1;
----
2

# ============================================================
# Multi-row INSERT
# ============================================================

statement ok
INSERT INTO dl.main.t_basic VALUES (10, {'i': 1, 'j': 1}), (11, {'i': 2, 'j': 2});

query IT
SELECT id, s FROM dl.main.t_basic WHERE id >= 10 ORDER BY id;
----
10	{'i': 1, 'j': 1}
11	{'i': 2, 'j': 2}

# ============================================================
# INSERT...SELECT with STRUCT
# ============================================================

statement ok
DROP TABLE IF EXISTS dl.main.t_struct_copy;

statement ok
CREATE TABLE dl.main.t_struct_copy(id INT, s STRUCT(i INTEGER, j INTEGER));

statement ok
INSERT INTO dl.main.t_struct_copy SELECT id, s FROM dl.main.t_basic WHERE id = 1;

query IT
SELECT id, s FROM dl.main.t_struct_copy;
----
1	{'i': 99, 'j': 100}

# ============================================================
# STRUCT equality in WHERE
# ============================================================

query IT
SELECT id, s FROM dl.main.t_basic WHERE s = {'i': 99, 'j': 100};
----
1	{'i': 99, 'j': 100}

query I
SELECT COUNT(*) FROM dl.main.t_basic WHERE s = {'i': 0, 'j': 0};
----
0

# ============================================================
# Cleanup
# ============================================================

statement ok
DROP TABLE IF EXISTS dl.main.t_struct_copy;

statement ok
DROP TABLE IF EXISTS dl.main.t_list_struct;

statement ok
DROP TABLE IF EXISTS dl.main.t_struct_list;

statement ok
DROP TABLE IF EXISTS dl.main.t_nested_struct;

statement ok
DROP TABLE IF EXISTS dl.main.t_mixed;

statement ok
DROP TABLE IF EXISTS dl.main.t_varchar_struct;

statement ok
DROP TABLE IF EXISTS dl.main.t_basic;

statement ok
DETACH dl;
