# name: test/sql/unit/ducklake_table_functions_conformance.test
# description: Verify native DuckLake table function behavior that DuckHog integration tests rely on.
# group: [unit]

#              If these fail, the assumptions in the RM11-13 integration tests are wrong.

require parquet

statement ok
INSTALL ducklake;

statement ok
LOAD ducklake;

statement ok
ATTACH 'ducklake:__TEST_DIR__/meta.db' AS dl;

# ============================================================
# snapshots() — RM12
# Schema: snapshot_id, snapshot_time, schema_version, changes,
#         author, commit_message, commit_extra_info
# ============================================================

# Initial attach creates snapshot 0
query I
SELECT COUNT(*) FROM dl.snapshots() WHERE snapshot_id = 0;
----
1

# snapshot_id is BIGINT, snapshot_time is TIMESTAMPTZ
query II
SELECT typeof(snapshot_id), typeof(snapshot_time) FROM dl.snapshots() LIMIT 1;
----
BIGINT	TIMESTAMP WITH TIME ZONE

# Each DDL/DML adds a snapshot
statement ok
CREATE TABLE dl.main.t(i INT, v VARCHAR);

statement ok
INSERT INTO dl.main.t VALUES (1, 'a'), (2, 'b');

statement ok
UPDATE dl.main.t SET v = 'x' WHERE i = 1;

statement ok
DELETE FROM dl.main.t WHERE i = 2;

# 5 snapshots: initial (0) + CREATE (1) + INSERT (2) + UPDATE (3) + DELETE (4)
query I
SELECT COUNT(*) FROM dl.snapshots();
----
5

# IDs are monotonically increasing
query I
SELECT COUNT(*) FROM (
  SELECT snapshot_id, LAG(snapshot_id) OVER (ORDER BY snapshot_id) AS prev
  FROM dl.snapshots()
) sub WHERE prev IS NOT NULL AND snapshot_id <= prev;
----
0

# snapshot_time is monotonically non-decreasing
query I
SELECT COUNT(*) FROM (
  SELECT snapshot_time, LAG(snapshot_time) OVER (ORDER BY snapshot_id) AS prev
  FROM dl.snapshots()
) sub WHERE prev IS NOT NULL AND snapshot_time < prev;
----
0

# changes column contains structured change info for every non-initial snapshot
query I
SELECT COUNT(*) FROM dl.snapshots() WHERE changes IS NOT NULL AND snapshot_id > 0;
----
4

# changes is MAP(VARCHAR, VARCHAR[])
query T
SELECT typeof(changes) FROM dl.snapshots() LIMIT 1;
----
MAP(VARCHAR, VARCHAR[])

# DDL (ALTER) also creates a snapshot
statement ok
ALTER TABLE dl.main.t ADD COLUMN extra INT;

query I
SELECT COUNT(*) FROM dl.snapshots();
----
6

# DROP TABLE creates a snapshot
statement ok
CREATE TABLE dl.main.drop_me(x INT);

statement ok
SET VARIABLE v_before_drop = (SELECT MAX(snapshot_id) FROM dl.snapshots());

statement ok
DROP TABLE dl.main.drop_me;

query I
SELECT (SELECT MAX(snapshot_id) FROM dl.snapshots()) - getvariable('v_before_drop');
----
1

# set_commit_message populates author, commit_message, commit_extra_info
statement ok
BEGIN;

statement ok
CALL dl.set_commit_message('testuser', 'test commit', extra_info => '{"key": "val"}');

statement ok
INSERT INTO dl.main.t VALUES (99, 'z', NULL);

statement ok
COMMIT;

query TTT
SELECT author, commit_message, commit_extra_info
FROM dl.snapshots() WHERE author IS NOT NULL;
----
testuser	test commit	{"key": "val"}

# ============================================================
# table_info() — RM13
# Schema: table_name, schema_id, table_id, table_uuid,
#         file_count, file_size_bytes, delete_file_count,
#         delete_file_size_bytes
# ============================================================

# Our table appears in table_info
query I
SELECT COUNT(*) FROM dl.table_info() WHERE table_name = 't';
----
1

# table_id and schema_id are BIGINT
query II
SELECT typeof(table_id), typeof(schema_id) FROM dl.table_info() LIMIT 1;
----
BIGINT	BIGINT

# file_count is positive (we inserted data)
query I
SELECT CASE WHEN file_count > 0 THEN 1 ELSE 0 END FROM dl.table_info() WHERE table_name = 't';
----
1

# delete_file_count is positive (we updated and deleted)
query I
SELECT CASE WHEN delete_file_count > 0 THEN 1 ELSE 0 END FROM dl.table_info() WHERE table_name = 't';
----
1

# file_size_bytes is positive after insert
query I
SELECT CASE WHEN file_size_bytes > 0 THEN 1 ELSE 0 END FROM dl.table_info() WHERE table_name = 't';
----
1

# table_uuid is unique across tables
statement ok
CREATE TABLE dl.main.t2(x INT);

query I
SELECT COUNT(DISTINCT table_uuid) FROM dl.table_info();
----
2

# Dropped table disappears from table_info
statement ok
CREATE TABLE dl.main.t_drop(x INT);

statement ok
INSERT INTO dl.main.t_drop VALUES (1);

query I
SELECT COUNT(*) FROM dl.table_info() WHERE table_name = 't_drop';
----
1

statement ok
DROP TABLE dl.main.t_drop;

query I
SELECT COUNT(*) FROM dl.table_info() WHERE table_name = 't_drop';
----
0

# After TRUNCATE: file_count drops to 0
statement ok
CREATE TABLE dl.main.t_trunc(x INT);

statement ok
INSERT INTO dl.main.t_trunc VALUES (1), (2), (3);

query I
SELECT CASE WHEN file_count > 0 THEN 1 ELSE 0 END FROM dl.table_info() WHERE table_name = 't_trunc';
----
1

statement ok
TRUNCATE TABLE dl.main.t_trunc;

query II
SELECT file_count, delete_file_count FROM dl.table_info() WHERE table_name = 't_trunc';
----
0	0

# ============================================================
# table_changes(table_name, start_snapshot, end_snapshot) — RM11
# Returns: snapshot_id, rowid, change_type, <table columns...>
# ============================================================

# Capture version boundaries (from the initial setup: CREATE=1, INSERT=2, UPDATE=3, DELETE=4)
statement ok
SET VARIABLE v_create = 1;

statement ok
SET VARIABLE v_insert = 2;

statement ok
SET VARIABLE v_update = 3;

statement ok
SET VARIABLE v_delete = 4;

# Full range: all changes from insert through delete
query IIT
SELECT snapshot_id, i, change_type FROM dl.table_changes('t', getvariable('v_insert'), getvariable('v_delete')) ORDER BY snapshot_id, i, change_type;
----
2	1	insert
2	2	insert
3	1	update_postimage
3	1	update_preimage
4	2	delete

# Single snapshot range (start == end): returns just that snapshot's changes
query IIT
SELECT snapshot_id, i, change_type FROM dl.table_changes('t', getvariable('v_insert'), getvariable('v_insert')) ORDER BY i;
----
2	1	insert
2	2	insert

# table_changes includes table column values
query IT
SELECT i, v FROM dl.table_changes('t', getvariable('v_insert'), getvariable('v_insert')) ORDER BY i;
----
1	a
2	b

# update shows pre and post images with correct values
query TIT
SELECT change_type, i, v FROM dl.table_changes('t', getvariable('v_update'), getvariable('v_update')) ORDER BY change_type;
----
update_postimage	1	x
update_preimage	1	a

# delete shows the deleted row values
query IT
SELECT i, v FROM dl.table_changes('t', getvariable('v_delete'), getvariable('v_delete'));
----
2	b

# table_changes uses table name without schema prefix
query I
SELECT COUNT(*) FROM dl.table_changes('t', getvariable('v_insert'), getvariable('v_delete'));
----
5

# Empty table: table_changes returns 0 rows for a table with no DML
statement ok
CREATE TABLE dl.main.t_empty(x INT);

statement ok
SET VARIABLE v_empty = (SELECT MAX(snapshot_id) FROM dl.snapshots());

query I
SELECT COUNT(*) FROM dl.table_changes('t_empty', getvariable('v_empty'), getvariable('v_empty'));
----
0

# Error: end_snapshot beyond current max
statement error
SELECT * FROM dl.table_changes('t', 1, 999999);
----
No snapshot found at version 999999

# Error: nonexistent table name
statement error
SELECT * FROM dl.table_changes('nonexistent', 1, 2);
----
Table with name nonexistent does not exist

# Schema-qualified name does NOT work (DuckLake resolves table name within catalog)
statement error
SELECT * FROM dl.table_changes('main.t', getvariable('v_insert'), getvariable('v_delete'));
----
does not exist

# TRUNCATE shows as individual delete change_types
statement ok
CREATE TABLE dl.main.t_tc_trunc(i INT);

statement ok
INSERT INTO dl.main.t_tc_trunc VALUES (1), (2);

statement ok
SET VARIABLE v_tc_trunc_ins = (SELECT MAX(snapshot_id) FROM dl.snapshots());

statement ok
TRUNCATE TABLE dl.main.t_tc_trunc;

statement ok
SET VARIABLE v_tc_trunc_del = (SELECT MAX(snapshot_id) FROM dl.snapshots());

query TI
SELECT change_type, i FROM dl.table_changes('t_tc_trunc', getvariable('v_tc_trunc_del'), getvariable('v_tc_trunc_del')) ORDER BY i;
----
delete	1
delete	2

# ADD COLUMN: old snapshots show NULL for new column
statement ok
CREATE TABLE dl.main.t_tc_evo(i INT);

statement ok
INSERT INTO dl.main.t_tc_evo VALUES (1);

statement ok
SET VARIABLE v_tc_evo_ins = (SELECT MAX(snapshot_id) FROM dl.snapshots());

statement ok
ALTER TABLE dl.main.t_tc_evo ADD COLUMN v VARCHAR;

statement ok
INSERT INTO dl.main.t_tc_evo VALUES (2, 'hello');

statement ok
SET VARIABLE v_tc_evo_ins2 = (SELECT MAX(snapshot_id) FROM dl.snapshots());

query IIT
SELECT i, v, change_type FROM dl.table_changes('t_tc_evo', getvariable('v_tc_evo_ins'), getvariable('v_tc_evo_ins2')) ORDER BY snapshot_id;
----
1	NULL	insert
2	hello	insert

# ============================================================
# Sentinel: catalog-scoped table function inventory
# If DuckLake adds new parameterized catalog-scoped table functions,
# this test will fail, alerting us to update the DuckHog proxy
# (which hardcodes known signatures).
# ============================================================

# Total unique DuckLake table functions/macros: 18
# The allowlist in posthog_schema_entry.cpp must match this count.
query I
SELECT COUNT(DISTINCT function_name) FROM duckdb_functions()
WHERE function_name LIKE 'ducklake_%'
  AND function_type IN ('table', 'table_macro');
----
18

# Zero-arg shorthands (single implicit catalog param): 5 functions
query I
SELECT COUNT(*) FROM duckdb_functions()
WHERE function_name LIKE 'ducklake_%'
  AND function_type = 'table'
  AND len(parameters) = 1;
----
5

# Parameterized table macros with catalog-scoped shorthand: only table_changes
query TT
SELECT function_name, function_type FROM duckdb_functions()
WHERE function_name LIKE 'ducklake_%'
  AND function_type = 'table_macro'
ORDER BY function_name;
----
ducklake_table_changes	table_macro

# ============================================================
# Cleanup
# ============================================================

statement ok
DETACH dl;
