# name: test/sql/integration/delete_remote.test_slow
# description: DELETE on remote DuckLake table
# group: [integration]

require duckhog

require-env FLIGHT_HOST

require-env FLIGHT_PORT

require-env DUCKHOG_USER

require-env DUCKHOG_PASSWORD

statement ok
ATTACH 'hog:ducklake?user=${DUCKHOG_USER}&password=${DUCKHOG_PASSWORD}&flight_server=grpc+tls://${FLIGHT_HOST}:${FLIGHT_PORT}&tls_skip_verify=true' AS remote_flight;

statement ok
DROP SCHEMA IF EXISTS remote_flight.delete_remote CASCADE;

statement ok
CREATE SCHEMA remote_flight.delete_remote;

statement ok
CREATE TABLE remote_flight.delete_remote.t(i INT, j INT DEFAULT 99);

statement ok
INSERT INTO remote_flight.delete_remote.t VALUES (1, 10), (2, 20), (3, 30), (4, 40), (5, 50);

# --- Basic DELETE with WHERE ---

query I
DELETE FROM remote_flight.delete_remote.t WHERE i = 1;
----
1

query II
SELECT i, j FROM remote_flight.delete_remote.t ORDER BY i;
----
2	20
3	30
4	40
5	50

# --- DELETE with no matching rows returns 0 ---

query I
DELETE FROM remote_flight.delete_remote.t WHERE i = -1;
----
0

query I
SELECT count(*) FROM remote_flight.delete_remote.t;
----
4

# --- DELETE multiple rows ---

query I
DELETE FROM remote_flight.delete_remote.t WHERE i > 3;
----
2

query II
SELECT i, j FROM remote_flight.delete_remote.t ORDER BY i;
----
2	20
3	30

# --- Re-insert for further tests ---

statement ok
INSERT INTO remote_flight.delete_remote.t VALUES (1, 10), (4, 40), (5, 50), (6, 60);

# --- DELETE without WHERE (delete all) ---

statement ok
CREATE TABLE remote_flight.delete_remote.t_all(x INT);

statement ok
INSERT INTO remote_flight.delete_remote.t_all VALUES (1), (2), (3);

query I
DELETE FROM remote_flight.delete_remote.t_all;
----
3

query I
SELECT count(*) FROM remote_flight.delete_remote.t_all;
----
0

# --- DELETE with complex WHERE ---

query I
DELETE FROM remote_flight.delete_remote.t WHERE i > 2 AND j < 50;
----
2

query II
SELECT i, j FROM remote_flight.delete_remote.t ORDER BY i;
----
1	10
2	20
5	50
6	60

# --- DELETE with IS NULL ---

statement ok
INSERT INTO remote_flight.delete_remote.t VALUES (NULL, NULL);

query I
DELETE FROM remote_flight.delete_remote.t WHERE i IS NULL;
----
1

query I
SELECT count(*) FROM remote_flight.delete_remote.t;
----
4

# --- DELETE with BETWEEN ---

query I
DELETE FROM remote_flight.delete_remote.t WHERE i BETWEEN 5 AND 6;
----
2

query II
SELECT i, j FROM remote_flight.delete_remote.t ORDER BY i;
----
1	10
2	20

# --- Transaction: ROLLBACK undoes DELETE ---

statement ok
INSERT INTO remote_flight.delete_remote.t VALUES (7, 70), (8, 80);

statement ok
BEGIN;

query I
DELETE FROM remote_flight.delete_remote.t WHERE i = 7;
----
1

statement ok
ROLLBACK;

query I
SELECT count(*) FROM remote_flight.delete_remote.t WHERE i = 7;
----
1

# --- Transaction: COMMIT persists DELETE ---

statement ok
BEGIN;

query I
DELETE FROM remote_flight.delete_remote.t WHERE i = 8;
----
1

statement ok
COMMIT;

query I
SELECT count(*) FROM remote_flight.delete_remote.t WHERE i = 8;
----
0

# --- DELETE with USING (join-based delete) ---

statement ok
CREATE TABLE remote_flight.delete_remote.blocklist(blocked_id INT);

statement ok
INSERT INTO remote_flight.delete_remote.blocklist VALUES (1), (2);

query I
DELETE FROM remote_flight.delete_remote.t USING remote_flight.delete_remote.blocklist WHERE t.i = blocklist.blocked_id;
----
2

query II
SELECT i, j FROM remote_flight.delete_remote.t ORDER BY i;
----
7	70

# --- DELETE with subquery in WHERE ---

statement ok
INSERT INTO remote_flight.delete_remote.t VALUES (10, 100), (11, 110);

statement ok
CREATE TABLE remote_flight.delete_remote.keep(keep_id INT);

statement ok
INSERT INTO remote_flight.delete_remote.keep VALUES (7);

query I
DELETE FROM remote_flight.delete_remote.t WHERE i NOT IN (SELECT keep_id FROM remote_flight.delete_remote.keep);
----
2

query II
SELECT i, j FROM remote_flight.delete_remote.t ORDER BY i;
----
7	70

# ============================================================
# DELETE ... RETURNING
# DuckHog wraps DELETE RETURNING in a CTE:
#   WITH __duckhog_deleted_rows AS (DELETE ... RETURNING *) SELECT ...
# The remote Duckgres server rejects this with "A CTE needs a SELECT"
# because DuckDB's CTE implementation requires SELECT, not DELETE/UPDATE.
# This affects ALL remote catalogs (DuckLake and memory).
# ============================================================

statement ok
CREATE TABLE remote_flight.delete_remote.ret_dl(id INT, name VARCHAR);

statement ok
INSERT INTO remote_flight.delete_remote.ret_dl VALUES (1, 'alice');

statement error
DELETE FROM remote_flight.delete_remote.ret_dl WHERE id = 1 RETURNING *;
----
CTE needs a SELECT

# ============================================================
# DELETE with LIKE / ILIKE in WHERE
# ============================================================

statement ok
CREATE TABLE remote_flight.delete_remote.like_test(id INT, name VARCHAR);

statement ok
INSERT INTO remote_flight.delete_remote.like_test VALUES
    (1, 'alice'), (2, 'alex'), (3, 'bob'), (4, 'Alice');

query I
DELETE FROM remote_flight.delete_remote.like_test WHERE name LIKE 'al%';
----
2

query T
SELECT name FROM remote_flight.delete_remote.like_test ORDER BY name;
----
Alice
bob

query I
DELETE FROM remote_flight.delete_remote.like_test WHERE name ILIKE 'al%';
----
1

query T
SELECT name FROM remote_flight.delete_remote.like_test;
----
bob

# ============================================================
# DELETE on empty table
# ============================================================

statement ok
CREATE TABLE remote_flight.delete_remote.empty_del(x INT);

query I
DELETE FROM remote_flight.delete_remote.empty_del;
----
0

query I
DELETE FROM remote_flight.delete_remote.empty_del WHERE x = 1;
----
0

# ============================================================
# Large DELETE (1000+ rows)
# ============================================================

statement ok
CREATE TABLE remote_flight.delete_remote.large(seq INT);

statement ok
INSERT INTO remote_flight.delete_remote.large SELECT i FROM range(1500) t(i);

# DuckHog may lose a few rows on large inserts (D4 â€” chunk boundary bug)
query I
SELECT COUNT(*) >= 1400 FROM remote_flight.delete_remote.large;
----
true

statement ok
DELETE FROM remote_flight.delete_remote.large WHERE seq < 1000;

# After deleting seq < 1000, only seq >= 1000 should remain
query I
SELECT MIN(seq) FROM remote_flight.delete_remote.large;
----
1000

# ============================================================
# DELETE with OR conditions
# ============================================================

statement ok
CREATE TABLE remote_flight.delete_remote.or_test(id INT, cat VARCHAR);

statement ok
INSERT INTO remote_flight.delete_remote.or_test VALUES
    (1, 'a'), (2, 'b'), (3, 'c'), (4, 'a'), (5, 'b');

query I
DELETE FROM remote_flight.delete_remote.or_test WHERE cat = 'a' OR cat = 'c';
----
3

query IT
SELECT id, cat FROM remote_flight.delete_remote.or_test ORDER BY id;
----
2	b
5	b

# --- Cleanup ---

statement ok
DROP SCHEMA remote_flight.delete_remote CASCADE;
