# name: test/sql/queries/session_token_invalidation_recovery.test_slow
# description: Expired session token should be invalidated after mutation failure so later RPCs can bootstrap again
# group: [queries]

require duckhog

require-env FLIGHT_HOST

require-env FLIGHT_PORT

require-env DUCKHOG_USER

require-env DUCKHOG_PASSWORD

# Guarded test mode:
# - start duckgres with DUCKGRES_FLIGHT_SESSION_TOKEN_TTL=1s
# - set DUCKHOG_TOKEN_EXPIRY_TEST=1
require-env DUCKGRES_FLIGHT_SESSION_TOKEN_TTL

require-env DUCKHOG_TOKEN_EXPIRY_TEST

statement ok
ATTACH 'hog:ducklake?user=${DUCKHOG_USER}&password=${DUCKHOG_PASSWORD}&flight_server=grpc+tls://${FLIGHT_HOST}:${FLIGHT_PORT}&tls_skip_verify=true' AS remote;

statement ok
DROP TABLE IF EXISTS remote.main.session_token_invalidation_recovery;

statement ok
CREATE TABLE remote.main.session_token_invalidation_recovery(id INTEGER, v VARCHAR);

statement ok
INSERT INTO remote.main.session_token_invalidation_recovery VALUES (1, 'a'), (2, 'b'), (3, 'c');

# Burn local CPU to exceed short token TTL between remote calls.
query I
SELECT SUM(i) FROM range(4000000000) t(i);
----
7999999998000000000

# This call should fail once due to an expired token.
statement error
INSERT INTO remote.main.session_token_invalidation_recovery VALUES (4, 'd');
----
session not found

# Client should clear stale token after the error; next call should bootstrap and succeed.
statement ok
INSERT INTO remote.main.session_token_invalidation_recovery VALUES (4, 'd');

query I
SELECT COUNT(*) FROM remote.main.session_token_invalidation_recovery;
----
4

statement ok
DROP TABLE remote.main.session_token_invalidation_recovery;
